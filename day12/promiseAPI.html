<!DOCTYPE html>
<html>
    <script>
       Promise.all([
        new Promise(resolve=>setTimeout(()=>resolve(1),3000)),
        new Promise(resolve=>setTimeout(()=>resolve(1),2000)),
        new Promise(resolve=>setTimeout(()=>resolve(1),1000))
       ]) .then(alert);
       /////
       let name=['iliakan','remy','jeresig'];
       let request=name.map(name=>fetch(`https://api.github.com/users/${name}`));
       Promise.all(requests)
       .then(Response=>{
        for(let Response of Response){
            alert(`${Response.url}:${Response.status}`);
        }
        return Response;
       })
       .then(Response=>Promise.all(Responses.map(r=>r.json())))
       .then(users=>users.forEach(user=>alert(user.name)));
       //////
       Promise.all([
        new Promise((resolve,reject)=reject>setTimeout(()=>resolve(1),1000)),
        new Promise((resolve,reject)=>setTimeout(()=>reject(new Error("Whoops!")),2000)),
        new Promise((resolve,reject)=>setTimeout(()=>resolve(3),3000))
       ]).then(alert);
       ///////\
       Promise.any([
        new Promise((resolve,reject)=>setTimeout(()=>reject(new Error("ouch")),1000)),
        new Promise((resolve,reject)=>setTimeout(()=>reject(new Error("Error")),2000))
       ]).catch(error=>{
        console.log(error.constructor.name);
        console.log(error.error[0]);
        console.log(error.error[1]);
       });
       //////////
       let cache=new Map();
       function loadcached(url){
        if(cache.has(url)){
            return Promise.resolve(cache.get(Url));
        }
       }
       //////
       Promise.all([
        new Promise((resolve,reject)=>{
            setTimeout((()=>resolve(1),1000))
        }),
        2,3
       ]).then(alert);
       ////////
       Promise.all([
        fetch('/template.html'),
        fetch('/style.css'),
        fetch ('/data.json')
       ]).then(render);
       ///////
       if(!Promise.allSettled){
        const rejectHandler=reson=>({
            status:'rejected',reason
        });
        const resolveHandler=function(Promise){
            Prmoise.allSettled=function(phrse){
                const convertedPromises= promis.map(p=>Promise.resolve(p)/then(resolveHandler,rejectHandler));
                return Promise .all(convertedPromises);
            }
        }
       }
       ////////
    Promise.any([
        new Promise((resolve,reject)=>setTimeout(()=>reject(new error("ouch")),1000)),
        new Promise((resolve,reject)=>setTimeout(()=>reject(new Error("Error")),2000))
    ]).catch(error=>{
        console.log(error.constructor.name);
        console.log(error.errors[0]);
        console.log(error.error[1]);
    });
    ////////
    let catch2=new Map();
    function loadcached(Url){
        if(cache.has(url)){
            return Promise.resolve(catche.get(url));
        }
        return fetch(url)
        .then(Response=>Response.text())
        .then(text=>{
            cache.set(url,text);
            return text;
        });
    }
    ///////
    let promise=new Promise((resolve,reject)=>reject(error));
    ////////
    </script>
<body>
</body>
</html>